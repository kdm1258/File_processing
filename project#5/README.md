# 과제 5: 레코드 삭제 및 삽입

## 주의사항
- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.

---

## 1. 개요

과제 5는 과제 4를 업그레이드한 것으로,  
(1) 레코드 삭제(delete)와 삽입(insert) 기능을 추가하고  
(2) 기존의 `search()` 함수를 수정한다.

---

## 2. 레코드 삭제 (delete)

- 특정 조건을 만족하는 레코드를 검색 후 삭제한다.
- 삭제는 해당 레코드의 **첫 바이트에 '*'** 를 저장하는 방식으로 처리한다.
- 삭제 시 헤더 레코드의 전체 레코드 수가 감소해야 한다.
- 삭제된 레코드는 **삭제 레코드 리스트**에 등록한다.
- 삭제 레코드 리스트는 `RRN` 기반으로 구성되며, `4바이트` 링크 값이 필요하다.
- 헤더 레코드의 **예약 공간 4바이트**는 삭제 리스트의 head RRN 저장용으로 사용된다.
- 삭제 리스트가 없다면 head는 `-1`로 저장한다.

**명령어 형식:**

```bash
$ a.out -d record_file_name "field_name=field_value"
```

**예시:**

```bash
$ a.out -d students.dat "SID=20201234"
```

**주의사항:**
- 헤더 레코드의 구성은:  
  `[4바이트] 전체 레코드 수 + [4바이트] 삭제 리스트 head RRN`  
  (둘 다 binary integer)
- 삭제 조건에 해당하는 레코드가 여러 개일 경우, 리스트 등록 순서는 무관함.

---

## 3. 레코드 삽입 (insert)

- 새로운 레코드 추가 시, 삭제 리스트가 존재하면 그 위치를 재사용한다.
- 삭제 리스트가 없을 경우, append 방식으로 삽입한다.
- 삽입 시 전체 레코드 수 증가, 삭제 리스트 수정 필요.

**명령어 형식:**

```bash
$ a.out -i record_file_name "field_value1" "field_value2" "field_value3" "field_value4" "field_value5"
```

**예시:**

```bash
$ a.out -i students.dat "20191234" "GD Hong" "Computer" "Dongjak-gu, Seoul" "gdhong@ssu.ac.kr"
```

**주의사항:**
- 삭제 리스트가 존재할 경우, 반드시 **리스트의 첫 번째 삭제 레코드 위치**에 삽입.
- 리스트도 함께 수정되어야 함.
- 삭제 리스트가 없으면 단순 append.

---

## 4. 검색 (search) 기능 수정

- 삭제 기능이 추가되었으므로, 검색 시 **삭제 레코드는 제외**해야 함.
- 명령어 및 출력 형식은 과제 4와 동일.
- 출력은 `print()` 함수 사용.
