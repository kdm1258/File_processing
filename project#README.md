# 과제 2: Flash Device Driver 활용
## 1. 개요 
- “Flash Memory” 강의에서 배운 Flash device driver에 대한 이해를 높이고 이를 활용하는 프로그램을 구현하며, 다음과 같은 제약 사항을 따라야 한다.
- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.
- 아래의 (1), (2), (3), (4), (5)의 기능을 ftlmgr.c에 구현한다.
- 아래 (2), (3), (4), (5)의 기능은 fdevicedriver.c의 인터페이스를 이용하여 구현한다.- fdevicedriver.c는 주어진 그대로 사용하며 수정해서는 안된다.

### (1) flash memory emulator
 Flash memory 저장 장치를 모방하는 flash memory 파일을 생성한다. 여기에는 n개의 블록과 각 블록에 m개의 페이지가 존재하며, 각 페이지는 하나의 512B 섹터영역(sector)과 16B 스페어영역(spare)으로 구성된다. 또한 블록은 8개의 페이지로 이루어져 있다 (즉, m=8). 아래의 명령어를 실행시키면 블록의 수 <#blocks>로 구성되는 flash memory 파일 <flashfile>을 생성한다. 

_a.out c <flashfile> <#blocks>_

**<예시>**
_a.out c flashmemory 10_

옵션으로 c를 사용하며, 10개의 블록과 각 블록은 8개의 물리적 페이지로 구성되는 flashmemory 파일을 생성한다 (파일 크기: 10*8*(512+16)=42,240B). 이때 모든 페이지의 모든 바이트는 0xFF로 초기화한다 (파일 전체를 0xFF로 채운다). Flash memory에서 ‘erase’ 연산도 결국 초기화 작업이기 때문에 파일에서 0xFF로 초기화하는 방법은 fdevicedriver.c의 fdd_erase() 함수를 활용하거나 참고하여 프로그래밍한다.

**<주의>**
- 생성한 flash memory 파일은 아래 (2), (3), (4)에서 사용한다.

### (2) 페이지 쓰기
Flash memory 저장장치에 페이지 단위로 데이터 쓰기를 수행한다. 아래 명령어를 실행시키면 <flashfile> 파일의 <ppn>의 물리적 페이지 번호를 가지는 페이지에, 섹터영역에는 <sectordata>를 스페어영역에는 <sparedata>를 저장한다. 만약 <flashfile>의 블록의 수가 10이고 페이지 수가 8이면 ppn=0, 1, 2, ..., 79가 된다. 실제 <sectordata>와 <sparedata>는 각각 512B와 16B가 되어야 하나 화면상에서 입력하기 어려우므로 그 크기가 작아도. 실행 결과를 화면에 출력할 필요가 없다.
_a.out w <flashfile> <ppn> <sectordata> <sparedata>_

**<예시>**
 _a.out w flashmemory 5 “abcd12345@%$” “12”_

옵션으로 w를 사용하며, ppn=5 즉, 6번째 페이지에 큰따옴표로 묶여있는 abcd12345@%$를 저장한다. 주어진 flashmemory 파일은 이미 생성되어 있어야 하며, 이 파일에는 최소한 6개의 페이지가 존재해야 한다. 주어진 섹터데이터를 해당 페이지의 섹터영영에 처음부터 차례로 저장한다. 만약 주어진 섹터데이터가 512B보다 적을 경우 나머지 공간은 0xFF로 채운다. abcd12345@%$를 6번째 페이지의 섹터영역에 처음부터 채우고 나머지 500B는 0xFF로 채운다. 스페어의 경우도 이와 같은 방식으로 처리한다.

**<주의>**
- <sectordata>와 <sparedata>는 blank를 포함할 수 있기 때문에 큰따옴표로 데이터를 
묶어서 입력한다. 그렇지 않는 경우 채점 시 정상적으로 동작하지 않는다.
- 섹터 데이터와 스페어 데이터는 키보드로 입력할 수 있는 문자로 표현한다.
- 이 명령어로는 동일한 페이지에 새로운 데이터로 갱신할 수 없다 (갱신을 위해서는 (5) 명령어를 사용해야 함).
- <sparedata>는 정수가 사용되며, 따라서 스페어영역에 저장할 때 반드시 4Byte “binary integer” 모드로 저장한다.

### (3) 페이지 읽기
(주의: ASCII character 모드가 아님)
 Flash memory 저장장치에서 페이지 단위로 읽기를 수행한다. 아래 명령어를 실행시키면 <flashfile> 파일의 <ppn>의 물리적 페이지 번호를 가지는 페이지에 저장되어 있는 섹터 데이터와 스페어 데이터를 화면에 출력한다.

 _a.out r <flashfile> <ppn>_
 
**<예시>**
 _a.out r flashmemory 5_
 _abcd12345@%$ 12_

옵션으로 r를 사용하며, flashmemory 파일의 ppn=5 페이지에서 섹터영역의 데이터와 스페어영역의 데이터를 읽어서 화면에 출력한다. 위의 (2)의 예시와 같이 데이터를 저장하였다고 가정한 것이며, 섹터 데이터는 스페어영역에서 첫 번째 0xFF 전까지의 의미있는 데이터를,스페어 데이터는 스페어영역에서 첫 4B의 정수값을 각각 출력한다.

**<주의>**
- 읽어야 할 페이지의 섹터영역에 의미있는 데이터가 존재하지 않는 경우 (섹터에 0xFF만 저장되어 있는 경우) 화면에 아무것도 출력할 필요가 없다.

### (4) 블록 소거(erase)
 Flash memory 저장장치에서 블록 단위로 블록 소거를 수행한다. 아래 명령어를 실행시키면 <flashfile> 파일의 <pbn>의 물리적 블록번호를 가지는 블록을 소거한다. 화면에 실행 결과를 출력할 필요가 없다.
 
_a.out e <flashfile> <pbn>_

 **<예시>**
 _a.out e flashmemory 3_

옵션 e를 사용하며, flashmemory 파일의 pbn=3 즉, 4번째 블록을 소거한다. 

### (5) In-place update
위의 (2)에서 구현한 페이지 쓰기 명령어를 이용하여 Flash memory에 여러 번의 쓰기를 수행했다고 가정할 때, 이미 데이터가 존재하는 페이지에 갱신(update)이 발생하면 강의자료처럼 in-place update를 수행한다. 강의자료처럼 해당 블록의 정상적인 페이지를 다른 페이지에 복사(copy)할 때 반드시 빈 블록을 하나 할당받아서 복사하는 제약을 둔다. 아래 명령어를 실행시키면 <flashfile> 파일의 <ppn> 번호의 페이지에 새로운 데이터 <sectordata>와 <sparedata>으로 갱신한다. 

_a.out u <flashfile> <ppn> <sectordata> <sparedata>_

 **<예시>**
 _a.out u flashmemory 11 “abcd6789@%$” “30”_
 _#reads=8 #writes=5 #erases=2_
옵션으로 u를 사용하며, flashmemory 파일의 ppn=11 즉, 12번째 페이지의 섹터영역과 스페어영역을 각각 abcd6789@%$와 30으로 갱신한다. 갱신하는 절차는 강의자료를 따른다. 갱신을 수행하는 과정에서 최소한의 읽기, 쓰기, 소거의 횟수를 각각 화면에 출력한다.
 
**<주의>**
- <sectordata>와 <sparedata>는 blank를 포함할 수 있으므로 큰따옴표로 데이터를 묶어서 입력한다. 그렇지 않는 경우 채점 시 정상적으로 동작하지 않는다.
- 섹터 데이터와 스페어 데이터는 키보드로 입력할 수 있는 문자로 표현한다.
- 이 명령어를 이용하여 동일한 페이지에 여러 번 갱신을 수행할 수 있다.
- <sparedata>는 정수가 사용되며, 따라서 스페어영역에 저장할 때 반드시 4Byte “binary integer” 모드로 저장한다.
 (주의: ASCII character 모드로 저장하지 말 것)- 반드시 위의 예시와 같이 출력 포맷을 따라야 한다.
